package kkpa.ai_services.ds;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import dev.langchain4j.data.embedding.Embedding;
import dev.langchain4j.model.embedding.EmbeddingModel;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import kkpa.ai_services.general.EmbeddingGenerationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@ApplicationScoped
public class EmbeddingServiceImpl implements EmbeddingService {

  private static final Logger logger = LoggerFactory.getLogger(EmbeddingServiceImpl.class);
  private final EmbeddingModel embeddingModel;
  private final ObjectMapper objectMapper;
  private final Executor executor = Executors.newFixedThreadPool(5);

  @Inject
  public EmbeddingServiceImpl(EmbeddingModel embeddingModel, ObjectMapper objectMapper) {
    this.embeddingModel = embeddingModel;
    this.objectMapper = objectMapper;
  }

  @Override
  public CompletableFuture<List<BuildingEmbedding>> generateEmbeddings(List<Building> buildings) {
    return CompletableFuture.supplyAsync(
        () -> {
          List<BuildingEmbedding> buildingEmbeddings = new ArrayList<>();

          for (Building building : buildings) {
            try {
              // Create a text representation of the building
              String text = createBuildingText(building);

              // Generate embedding using LangChain4j
              Embedding embedding = embeddingModel.embed(text).content();

              // Create JSON metadata
              String metadata = createMetadata(building);

              // Create the building embedding object
              BuildingEmbedding buildingEmbedding =
                  new BuildingEmbedding(
                      null, // UUID will be generated by the database
                      building.id(),
                      text,
                      embedding.vector(),
                      metadata,
                      null, // createdAt will be set by the database
                      null // updatedAt will be set by the database
                      );

              buildingEmbeddings.add(buildingEmbedding);
              logger.debug("Generated embedding for building {}", building.id());
            } catch (Exception e) {
              logger.error("Failed to generate embedding for building {}", building.id(), e);
              throw new EmbeddingGenerationException(
                  "Failed to generate embedding for building " + building.id(), e);
            }
          }

          logger.info("Generated {} embeddings", buildingEmbeddings.size());
          return buildingEmbeddings;
        },
        executor);
  }

  private String createBuildingText(Building building) {
    StringBuilder text = new StringBuilder();
    text.append("Building ID: ").append(building.id()).append(". ");

    if (building.buildingType() != null) {
      text.append("Type: ").append(building.buildingType()).append(". ");
    }

    if (building.cityName() != null) {
      text.append("City: ").append(building.cityName());

      if (building.state() != null) {
        text.append(", ").append(building.state());
      }

      text.append(". ");
    }

    return text.toString();
  }

  private String createMetadata(Building building) throws JsonProcessingException {
    return objectMapper.writeValueAsString(building);
  }
}
